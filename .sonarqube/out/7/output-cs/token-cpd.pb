Ωª
OC:\ProgramData\Jenkins\.jenkins\workspace\GamePipeline\Projects\Maze\Program.cs
class

 
Program

 
{ 
static 
void 
Main 
( 
) 
{ 
if 
( 
OperatingSystem 
. 
	IsWindows 
(  
)  !
)! "
{ 
Console 

.
 
WindowHeight 
= 
$num 
; 
} 
const 
int 
rows 
= 
$num 
; 
const 
int 
columns 
= 
$num 
; 
static 
Maze	 
. 
Tile 
[ 
, 
] 
GenerateMaze "
(" #
)# $
=>% '
Maze 
. 
Generate 
( 
rows 
, 
columns 
) 
;  
Console$$ 	
.$$	 

CursorVisible$$
 
=$$ 
true$$ 
;$$ 
Maze%% 
.%% 
Tile%% 
[%% 
,%% 
]%% 
maze%% 
=%% 
GenerateMaze%% "
(%%" #
)%%# $
;%%$ %
Console&& 	
.&&	 

Clear&&
 
(&& 
)&& 
;&& 
Console'' 	
.''	 

	WriteLine''
 
('' 
Maze'' 
.'' 
Render'' 
(''  
maze''  $
)''$ %
)''% &
;''& '
Console(( 	
.((	 

	WriteLine((
 
((( 
)(( 
;(( 
Console)) 	
.))	 

	WriteLine))
 
()) 
$str)) 
))) 
;)) 
Console** 	
.**	 

	WriteLine**
 
(** 
$str** =
)**= >
;**> ?
Console++ 	
.++	 

	WriteLine++
 
(++ 
$str++ +
)+++ ,
;++, -
int,, 
row,, 	
=,,
 
$num,, 
;,, 
int-- 
column-- 
=-- 
$num-- 
;-- 
while.. 
(.. 	
row..	 
!=.. 
rows.. 
-.. 
$num.. 
||.. 
column.. "
!=..# %
columns..& -
-... /
$num..0 1
)..1 2
{// 
Console00 

.00
 
SetCursorPosition00 
(00 
column00 #
*00$ %
$num00& '
+00( )
$num00* +
,00+ ,
row00- 0
*001 2
$num003 4
+005 6
$num007 8
)008 9
;009 :
switch11 	
(11
 
Console11 
.11 
ReadKey11 
(11 
)11 
.11 
Key11  
)11  !
{22 
case33 

ConsoleKey33	 
.33 
UpArrow33 
:33 
if44 
(44 	
maze44	 
[44 
row44 
,44 
column44 
]44 
.44 
HasFlag44 "
(44" #
Maze44# '
.44' (
Tile44( ,
.44, -
Up44- /
)44/ 0
)440 1
row55 	
--55	 
;55 
break66 

;66
 
case77 

ConsoleKey77	 
.77 
	DownArrow77 
:77 
if88 
(88 	
maze88	 
[88 
row88 
,88 
column88 
]88 
.88 
HasFlag88 "
(88" #
Maze88# '
.88' (
Tile88( ,
.88, -
Down88- 1
)881 2
)882 3
row99 	
++99	 
;99 
break:: 

;::
 
case;; 

ConsoleKey;;	 
.;; 
	LeftArrow;; 
:;; 
if<< 
(<< 	
maze<<	 
[<< 
row<< 
,<< 
column<< 
]<< 
.<< 
HasFlag<< "
(<<" #
Maze<<# '
.<<' (
Tile<<( ,
.<<, -
Left<<- 1
)<<1 2
)<<2 3
column== 
--== 
;== 
break>> 

;>>
 
case?? 

ConsoleKey??	 
.?? 

RightArrow?? 
:?? 
if@@ 
(@@ 	
maze@@	 
[@@ 
row@@ 
,@@ 
column@@ 
]@@ 
.@@ 
HasFlag@@ "
(@@" #
Maze@@# '
.@@' (
Tile@@( ,
.@@, -
Right@@- 2
)@@2 3
)@@3 4
columnAA 
++AA 
;AA 
breakBB 

;BB
 
caseCC 

ConsoleKeyCC	 
.CC 
EscapeCC 
:CC 
ConsoleDD 
.DD 
ClearDD 
(DD 
)DD 
;DD 
ConsoleEE 
.EE 
WriteEE 
(EE 
$strEE &
)EE& '
;EE' (
returnFF 
;FF 
}GG 
}HH 
ConsoleII 	
.II	 

ClearII
 
(II 
)II 
;II 
ConsoleJJ 	
.JJ	 

WriteJJ
 
(JJ 
$strJJ 
)JJ 
;JJ 
}LL 
}MM 
publicOO 
staticOO 
classOO 
MazeOO 
{PP 
[QQ 
FlagsQQ 
]QQ 
publicRR 
enumRR 
TileRR 
{SS 
NullTT 
=TT 
$numTT	 

,TT
 
UpUU 
=UU 
$numUU 
,UU 	
DownVV 
=VV 
$numVV	 

,VV
 
LeftWW 
=WW 
$numWW	 

,WW
 
RightXX 
=XX 	
$numXX
 
,XX 
StartYY 
=YY 	
$numYY
 
,YY 
EndZZ 
=ZZ 
$numZZ 

,ZZ
 
}[[ 
internal__ 	
class__
 
Node__ 
{`` 
internalaa 

intaa 
Rowaa 
;aa 
internalbb 

intbb 
Columnbb 
;bb 
internalcc 

boolcc 

UpExploredcc 
;cc 
internaldd 

booldd 
DownExploreddd 
;dd 
internalee 

boolee 
LeftExploredee 
;ee 
internalff 

boolff 
RightExploredff 
;ff 
}gg 
publicii 
staticii 
Tileii 
[ii 
,ii 
]ii 
Generateii 
(ii  
intjj 
rowsjj 

,jj
 
intjj 
columnsjj 
,jj 
intkk 
?kk 
	start_rowkk 
=kk 
nullkk 
,kk 
intkk 
?kk 
start_columnkk *
=kk+ ,
nullkk- 1
,kk1 2
intll 
?ll 
end_rowll 
=ll 
nullll 
,ll 
intll 
?ll 

end_columnll &
=ll' (
nullll) -
)ll- .
{mm 
	start_rowoo 
??=oo 
$numoo 
;oo 
start_columnpp 
??=pp 
$numpp 
;pp 
end_rowqq 	
??=qq
 
rowsqq 
-qq 
$numqq 
;qq 

end_columnrr 
??=rr 
columnsrr 
-rr 
$numrr 
;rr 
ifuu 
(uu 
rowsuu 

<=uu 
$numuu 
)uu 
throwvv 
newvv	 '
ArgumentOutOfRangeExceptionvv (
(vv( )
nameofvv) /
(vv/ 0
rowsvv0 4
)vv4 5
)vv5 6
;vv6 7
ifww 
(ww 
columnsww 
<=ww 
$numww 
)ww 
throwxx 
newxx	 '
ArgumentOutOfRangeExceptionxx (
(xx( )
nameofxx) /
(xx/ 0
columnsxx0 7
)xx7 8
)xx8 9
;xx9 :
ifyy 
(yy 
	start_rowyy 
<yy 
$numyy 
||yy 
rowsyy 
<yy 
	start_rowyy '
)yy' (
throwzz 
newzz	 '
ArgumentOutOfRangeExceptionzz (
(zz( )
nameofzz) /
(zz/ 0
	start_rowzz0 9
)zz9 :
)zz: ;
;zz; <
if{{ 
({{ 
end_row{{ 
<{{ 
$num{{ 
||{{ 
rows{{ 
<{{ 
end_row{{ #
||{{$ &
	start_row{{' 0
=={{1 3
end_row{{4 ;
){{; <
throw|| 
new||	 '
ArgumentOutOfRangeException|| (
(||( )
nameof||) /
(||/ 0
end_row||0 7
)||7 8
)||8 9
;||9 :
if}} 
(}} 
start_column}} 
<}} 
$num}} 
||}} 
columns}} !
<}}" #
start_column}}$ 0
)}}0 1
throw~~ 
new~~	 '
ArgumentOutOfRangeException~~ (
(~~( )
nameof~~) /
(~~/ 0
start_column~~0 <
)~~< =
)~~= >
;~~> ?
if 
( 

end_column 
< 
$num 
|| 
columns 
<  !

end_column" ,
||- /
start_column0 <
=== ?

end_column@ J
)J K
throw
ÄÄ 
new
ÄÄ	 )
ArgumentOutOfRangeException
ÄÄ (
(
ÄÄ( )
nameof
ÄÄ) /
(
ÄÄ/ 0

end_column
ÄÄ0 :
)
ÄÄ: ;
)
ÄÄ; <
;
ÄÄ< =
Tile
ÉÉ 
[
ÉÉ 
,
ÉÉ 
]
ÉÉ 	
maze
ÉÉ
 
=
ÉÉ 
new
ÉÉ 
Tile
ÉÉ 
[
ÉÉ 
rows
ÉÉ 
,
ÉÉ 
columns
ÉÉ  '
]
ÉÉ' (
;
ÉÉ( )
Random
ÑÑ 
random
ÑÑ	 
=
ÑÑ 
new
ÑÑ 
(
ÑÑ 
)
ÑÑ 
;
ÑÑ 
var
ÖÖ 
directionBuffer
ÖÖ 
=
ÖÖ 
new
ÖÖ 
(
ÖÖ 
int
ÖÖ  
Row
ÖÖ! $
,
ÖÖ$ %
int
ÖÖ& )
Column
ÖÖ* 0
)
ÖÖ0 1
[
ÖÖ1 2
$num
ÖÖ2 3
]
ÖÖ3 4
;
ÖÖ4 5
maze
áá 
[
áá 
	start_row
áá 
.
áá 
Value
áá 
,
áá 
start_column
áá $
.
áá$ %
Value
áá% *
]
áá* +
=
áá, -
Tile
áá. 2
.
áá2 3
Start
áá3 8
;
áá8 9
maze
àà 
[
àà 
end_row
àà 
.
àà 
Value
àà 
,
àà 

end_column
àà  
.
àà  !
Value
àà! &
]
àà& '
=
àà( )
Tile
àà* .
.
àà. /
End
àà/ 2
;
àà2 3
{
ãã 
var
åå 
stack
åå 
=
åå 
new
åå 
Stack
åå 
<
åå 
Node
åå 
>
åå 
(
åå 
)
åå  
;
åå  !
stack
çç 
.
çç 	
Push
çç	 
(
çç 
new
çç 
Node
çç 
(
çç 
)
çç 
{
éé 
Row
èè 
=
èè 	
	start_row
èè
 
.
èè 
Value
èè 
,
èè 
Column
êê 

=
êê 
start_column
êê 
.
êê 
Value
êê 
,
êê  
}
ëë 
)
ëë 
;
ëë 
bool
õõ 
DefaultLocations
õõ 
(
õõ 
)
õõ 
=>
õõ 
	start_row
úú 
==
úú 
$num
úú 
&&
úú 
start_column
úú "
==
úú# %
$num
úú& '
&&
úú( *
end_row
ùù 
==
ùù 
rows
ùù 
-
ùù 
$num
ùù 
&&
ùù 

end_column
ùù %
==
ùù& (
columns
ùù) 0
-
ùù1 2
$num
ùù3 4
;
ùù4 5
bool
ûû 
UpOptimization
ûû 
(
ûû 
int
ûû 
column
ûû !
)
ûû! "
=>
ûû# %
!
ûû& '
(
ûû' (
DefaultLocations
ûû( 8
(
ûû8 9
)
ûû9 :
&&
ûû; =
column
ûû> D
==
ûûE G
columns
ûûH O
-
ûûP Q
$num
ûûR S
||
ûûT V
column
ûûW ]
==
ûû^ `
$num
ûûa b
)
ûûb c
;
ûûc d
bool
üü 
LeftOptimization
üü 
(
üü 
int
üü 
row
üü  
)
üü  !
=>
üü" $
!
üü% &
(
üü& '
DefaultLocations
üü' 7
(
üü7 8
)
üü8 9
&&
üü: <
row
üü= @
==
üüA C
rows
üüD H
-
üüI J
$num
üüK L
||
üüM O
row
üüP S
==
üüT V
$num
üüW X
)
üüX Y
;
üüY Z
static
££ 	
bool
££
 
	NullOrEnd
££ 
(
££ 
Tile
££ 
tile
££ "
)
££" #
=>
££$ &
tile
££' +
is
££, .
Tile
££/ 3
.
££3 4
Null
££4 8
||
££9 ;
tile
££< @
is
££A C
Tile
££D H
.
££H I
End
££I L
;
££L M
bool
•• 

MoveRandom
•• 
(
•• 
)
•• 
{
¶¶ 
Node
ßß 
node
ßß	 
=
ßß 
stack
ßß 
.
ßß 
Peek
ßß 
(
ßß 
)
ßß 
;
ßß 
int
®® 
i
®® 	
=
®®
 
$num
®® 
;
®® 
if
™™ 
(
™™ 
node
™™ 
.
™™ 
Row
™™ 
!=
™™ 
rows
™™ 
-
™™ 
$num
™™ 
&&
™™ 
	NullOrEnd
™™  )
(
™™) *
maze
™™* .
[
™™. /
node
™™/ 3
.
™™3 4
Row
™™4 7
+
™™8 9
$num
™™: ;
,
™™; <
node
™™= A
.
™™A B
Column
™™B H
]
™™H I
)
™™I J
&&
™™K M
!
™™N O
node
™™O S
.
™™S T
DownExplored
™™T `
)
™™` a
directionBuffer
´´ 
[
´´ 
i
´´ 
++
´´ 
]
´´ 
=
´´ 
(
´´ 
node
´´ !
.
´´! "
Row
´´" %
+
´´& '
$num
´´( )
,
´´) *
node
´´+ /
.
´´/ 0
Column
´´0 6
)
´´6 7
;
´´7 8
if
¨¨ 
(
¨¨ 
node
¨¨ 
.
¨¨ 
Row
¨¨ 
!=
¨¨ 
$num
¨¨ 
&&
¨¨ 
	NullOrEnd
¨¨ "
(
¨¨" #
maze
¨¨# '
[
¨¨' (
node
¨¨( ,
.
¨¨, -
Row
¨¨- 0
-
¨¨1 2
$num
¨¨3 4
,
¨¨4 5
node
¨¨6 :
.
¨¨: ;
Column
¨¨; A
]
¨¨A B
)
¨¨B C
&&
¨¨D F
!
¨¨G H
node
¨¨H L
.
¨¨L M

UpExplored
¨¨M W
&&
¨¨X Z
UpOptimization
¨¨[ i
(
¨¨i j
node
¨¨j n
.
¨¨n o
Column
¨¨o u
)
¨¨u v
)
¨¨v w
directionBuffer
≠≠ 
[
≠≠ 
i
≠≠ 
++
≠≠ 
]
≠≠ 
=
≠≠ 
(
≠≠ 
node
≠≠ !
.
≠≠! "
Row
≠≠" %
-
≠≠& '
$num
≠≠( )
,
≠≠) *
node
≠≠+ /
.
≠≠/ 0
Column
≠≠0 6
)
≠≠6 7
;
≠≠7 8
if
ÆÆ 
(
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Column
ÆÆ 
!=
ÆÆ 
$num
ÆÆ 
&&
ÆÆ 
	NullOrEnd
ÆÆ %
(
ÆÆ% &
maze
ÆÆ& *
[
ÆÆ* +
node
ÆÆ+ /
.
ÆÆ/ 0
Row
ÆÆ0 3
,
ÆÆ3 4
node
ÆÆ5 9
.
ÆÆ9 :
Column
ÆÆ: @
-
ÆÆA B
$num
ÆÆC D
]
ÆÆD E
)
ÆÆE F
&&
ÆÆG I
!
ÆÆJ K
node
ÆÆK O
.
ÆÆO P
LeftExplored
ÆÆP \
&&
ÆÆ] _
LeftOptimization
ÆÆ` p
(
ÆÆp q
node
ÆÆq u
.
ÆÆu v
Row
ÆÆv y
)
ÆÆy z
)
ÆÆz {
directionBuffer
ØØ 
[
ØØ 
i
ØØ 
++
ØØ 
]
ØØ 
=
ØØ 
(
ØØ 
node
ØØ !
.
ØØ! "
Row
ØØ" %
,
ØØ% &
node
ØØ' +
.
ØØ+ ,
Column
ØØ, 2
-
ØØ3 4
$num
ØØ5 6
)
ØØ6 7
;
ØØ7 8
if
∞∞ 
(
∞∞ 
node
∞∞ 
.
∞∞ 
Column
∞∞ 
!=
∞∞ 
columns
∞∞ 
-
∞∞  
$num
∞∞! "
&&
∞∞# %
	NullOrEnd
∞∞& /
(
∞∞/ 0
maze
∞∞0 4
[
∞∞4 5
node
∞∞5 9
.
∞∞9 :
Row
∞∞: =
,
∞∞= >
node
∞∞? C
.
∞∞C D
Column
∞∞D J
+
∞∞K L
$num
∞∞M N
]
∞∞N O
)
∞∞O P
&&
∞∞Q S
!
∞∞T U
node
∞∞U Y
.
∞∞Y Z
RightExplored
∞∞Z g
)
∞∞g h
directionBuffer
±± 
[
±± 
i
±± 
++
±± 
]
±± 
=
±± 
(
±± 
node
±± !
.
±±! "
Row
±±" %
,
±±% &
node
±±' +
.
±±+ ,
Column
±±, 2
+
±±3 4
$num
±±5 6
)
±±6 7
;
±±7 8
if
≥≥ 
(
≥≥ 
i
≥≥ 	
is
≥≥
 
$num
≥≥ 
)
≥≥ 
{
¥¥ 
return
µµ 
false
µµ 
;
µµ 
}
∂∂ 
var
∏∏ 
move
∏∏ 
=
∏∏ 
directionBuffer
∏∏ 
[
∏∏ 
random
∏∏ %
.
∏∏% &
Next
∏∏& *
(
∏∏* +
$num
∏∏+ ,
,
∏∏, -
i
∏∏. /
)
∏∏/ 0
]
∏∏0 1
;
∏∏1 2
if
∫∫ 
(
∫∫ 
move
∫∫ 
.
∫∫ 
Row
∫∫ 
==
∫∫ 
node
∫∫ 
.
∫∫ 
Row
∫∫ 
+
∫∫ 
$num
∫∫  
)
∫∫  !
{
ªª 
node
ºº 	
.
ºº	 

DownExplored
ºº
 
=
ºº 
true
ºº 
;
ºº 
maze
ΩΩ 	
[
ΩΩ	 

node
ΩΩ
 
.
ΩΩ 
Row
ΩΩ 
,
ΩΩ 
node
ΩΩ 
.
ΩΩ 
Column
ΩΩ 
]
ΩΩ  
|=
ΩΩ! #
Tile
ΩΩ$ (
.
ΩΩ( )
Down
ΩΩ) -
;
ΩΩ- .
maze
ææ 	
[
ææ	 

move
ææ
 
.
ææ 
Row
ææ 
,
ææ 
move
ææ 
.
ææ 
Column
ææ 
]
ææ  
|=
ææ! #
Tile
ææ$ (
.
ææ( )
Up
ææ) +
;
ææ+ ,
}
øø 
if
¿¿ 
(
¿¿ 
move
¿¿ 
.
¿¿ 
Row
¿¿ 
==
¿¿ 
node
¿¿ 
.
¿¿ 
Row
¿¿ 
-
¿¿ 
$num
¿¿  
)
¿¿  !
{
¡¡ 
node
¬¬ 	
.
¬¬	 


UpExplored
¬¬
 
=
¬¬ 
true
¬¬ 
;
¬¬ 
maze
√√ 	
[
√√	 

node
√√
 
.
√√ 
Row
√√ 
,
√√ 
node
√√ 
.
√√ 
Column
√√ 
]
√√  
|=
√√! #
Tile
√√$ (
.
√√( )
Up
√√) +
;
√√+ ,
maze
ƒƒ 	
[
ƒƒ	 

move
ƒƒ
 
.
ƒƒ 
Row
ƒƒ 
,
ƒƒ 
move
ƒƒ 
.
ƒƒ 
Column
ƒƒ 
]
ƒƒ  
|=
ƒƒ! #
Tile
ƒƒ$ (
.
ƒƒ( )
Down
ƒƒ) -
;
ƒƒ- .
}
≈≈ 
if
∆∆ 
(
∆∆ 
move
∆∆ 
.
∆∆ 
Column
∆∆ 
==
∆∆ 
node
∆∆ 
.
∆∆ 
Column
∆∆ "
-
∆∆# $
$num
∆∆% &
)
∆∆& '
{
«« 
node
»» 	
.
»»	 

LeftExplored
»»
 
=
»» 
true
»» 
;
»» 
maze
…… 	
[
……	 

node
……
 
.
…… 
Row
…… 
,
…… 
node
…… 
.
…… 
Column
…… 
]
……  
|=
……! #
Tile
……$ (
.
……( )
Left
……) -
;
……- .
maze
   	
[
  	 

move
  
 
.
   
Row
   
,
   
move
   
.
   
Column
   
]
    
|=
  ! #
Tile
  $ (
.
  ( )
Right
  ) .
;
  . /
}
ÀÀ 
if
ÃÃ 
(
ÃÃ 
move
ÃÃ 
.
ÃÃ 
Column
ÃÃ 
==
ÃÃ 
node
ÃÃ 
.
ÃÃ 
Column
ÃÃ "
+
ÃÃ# $
$num
ÃÃ% &
)
ÃÃ& '
{
ÕÕ 
node
ŒŒ 	
.
ŒŒ	 

RightExplored
ŒŒ
 
=
ŒŒ 
true
ŒŒ 
;
ŒŒ 
maze
œœ 	
[
œœ	 

node
œœ
 
.
œœ 
Row
œœ 
,
œœ 
node
œœ 
.
œœ 
Column
œœ 
]
œœ  
|=
œœ! #
Tile
œœ$ (
.
œœ( )
Right
œœ) .
;
œœ. /
maze
–– 	
[
––	 

move
––
 
.
–– 
Row
–– 
,
–– 
move
–– 
.
–– 
Column
–– 
]
––  
|=
––! #
Tile
––$ (
.
––( )
Left
––) -
;
––- .
}
—— 
stack
““ 	
.
““	 

Push
““
 
(
““ 
new
““ 
Node
““ 
(
““ 
)
““ 
{
”” 
Row
‘‘ 
=
‘‘	 

move
‘‘ 
.
‘‘ 
Row
‘‘ 
,
‘‘ 
Column
’’ 
=
’’ 
move
’’ 
.
’’ 
Column
’’ 
,
’’ 
}
÷÷ 
)
÷÷ 
;
÷÷ 
return
ÿÿ 

true
ÿÿ 
;
ÿÿ 
}
ŸŸ 
while
€€ 
(
€€	 

stack
€€
 
.
€€ 
Peek
€€ 
(
€€ 
)
€€ 
.
€€ 
Row
€€ 
!=
€€ 
end_row
€€ %
||
€€& (
stack
€€) .
.
€€. /
Peek
€€/ 3
(
€€3 4
)
€€4 5
.
€€5 6
Column
€€6 <
!=
€€= ?

end_column
€€@ J
)
€€J K
{
‹‹ 
if
›› 
(
›› 
!
›› 	

MoveRandom
››	 
(
›› 
)
›› 
)
›› 
{
ﬁﬁ 
Node
ﬂﬂ 	
move
ﬂﬂ
 
=
ﬂﬂ 
stack
ﬂﬂ 
.
ﬂﬂ 
Pop
ﬂﬂ 
(
ﬂﬂ 
)
ﬂﬂ 
;
ﬂﬂ 
maze
‡‡ 	
[
‡‡	 

move
‡‡
 
.
‡‡ 
Row
‡‡ 
,
‡‡ 
move
‡‡ 
.
‡‡ 
Column
‡‡ 
]
‡‡  
=
‡‡! "
Tile
‡‡# '
.
‡‡' (
Null
‡‡( ,
;
‡‡, -
Node
·· 	
parent
··
 
=
·· 
stack
·· 
.
·· 
Peek
·· 
(
·· 
)
·· 
;
··  
if
‚‚ 
(
‚‚ 	
move
‚‚	 
.
‚‚ 
Row
‚‚ 
==
‚‚ 
parent
‚‚ 
.
‚‚ 
Row
‚‚ 
-
‚‚  !
$num
‚‚" #
)
‚‚# $
maze
‚‚% )
[
‚‚) *
parent
‚‚* 0
.
‚‚0 1
Row
‚‚1 4
,
‚‚4 5
parent
‚‚6 <
.
‚‚< =
Column
‚‚= C
]
‚‚C D
&=
‚‚E G
~
‚‚H I
Tile
‚‚I M
.
‚‚M N
Up
‚‚N P
;
‚‚P Q
if
„„ 
(
„„ 	
move
„„	 
.
„„ 
Row
„„ 
==
„„ 
parent
„„ 
.
„„ 
Row
„„ 
+
„„  !
$num
„„" #
)
„„# $
maze
„„% )
[
„„) *
parent
„„* 0
.
„„0 1
Row
„„1 4
,
„„4 5
parent
„„6 <
.
„„< =
Column
„„= C
]
„„C D
&=
„„E G
~
„„H I
Tile
„„I M
.
„„M N
Down
„„N R
;
„„R S
if
‰‰ 
(
‰‰ 	
move
‰‰	 
.
‰‰ 
Column
‰‰ 
==
‰‰ 
parent
‰‰ 
.
‰‰ 
Column
‰‰ %
+
‰‰& '
$num
‰‰( )
)
‰‰) *
maze
‰‰+ /
[
‰‰/ 0
parent
‰‰0 6
.
‰‰6 7
Row
‰‰7 :
,
‰‰: ;
parent
‰‰< B
.
‰‰B C
Column
‰‰C I
]
‰‰I J
&=
‰‰K M
~
‰‰N O
Tile
‰‰O S
.
‰‰S T
Right
‰‰T Y
;
‰‰Y Z
if
ÂÂ 
(
ÂÂ 	
move
ÂÂ	 
.
ÂÂ 
Column
ÂÂ 
==
ÂÂ 
parent
ÂÂ 
.
ÂÂ 
Column
ÂÂ %
-
ÂÂ& '
$num
ÂÂ( )
)
ÂÂ) *
maze
ÂÂ+ /
[
ÂÂ/ 0
parent
ÂÂ0 6
.
ÂÂ6 7
Row
ÂÂ7 :
,
ÂÂ: ;
parent
ÂÂ< B
.
ÂÂB C
Column
ÂÂC I
]
ÂÂI J
&=
ÂÂK M
~
ÂÂN O
Tile
ÂÂO S
.
ÂÂS T
Left
ÂÂT X
;
ÂÂX Y
}
ÊÊ 
}
ÓÓ 
}
ÔÔ 
{
ÚÚ 
var
ÛÛ 
stack
ÛÛ 
=
ÛÛ 
new
ÛÛ 
Stack
ÛÛ 
<
ÛÛ 
Node
ÛÛ 
>
ÛÛ 
(
ÛÛ 
)
ÛÛ  
;
ÛÛ  !
var
ÙÙ 
invalidPath
ÙÙ 
=
ÙÙ 
new
ÙÙ 
HashSet
ÙÙ  
<
ÙÙ  !
(
ÙÙ! "
int
ÙÙ" %
Row
ÙÙ& )
,
ÙÙ) *
int
ÙÙ+ .
Column
ÙÙ/ 5
)
ÙÙ5 6
>
ÙÙ6 7
(
ÙÙ7 8
)
ÙÙ8 9
;
ÙÙ9 :
Tile
ıı 
previousMove
ıı 
;
ıı 
int
˜˜ 

CountNulls
˜˜ 
(
˜˜ 
)
˜˜ 
{
¯¯ 
int
˘˘ 
count
˘˘ 
=
˘˘ 
$num
˘˘ 
;
˘˘ 
for
˙˙ 
(
˙˙ 	
int
˙˙	 
row
˙˙ 
=
˙˙ 
$num
˙˙ 
;
˙˙ 
row
˙˙ 
<
˙˙ 
rows
˙˙  
;
˙˙  !
row
˙˙" %
++
˙˙% '
)
˙˙' (
for
˚˚ 
(
˚˚	 

int
˚˚
 
column
˚˚ 
=
˚˚ 
$num
˚˚ 
;
˚˚ 
column
˚˚  
<
˚˚! "
columns
˚˚# *
;
˚˚* +
column
˚˚, 2
++
˚˚2 4
)
˚˚4 5
if
¸¸ 
(
¸¸	 

maze
¸¸
 
[
¸¸ 
row
¸¸ 
,
¸¸ 
column
¸¸ 
]
¸¸ 
is
¸¸ 
Tile
¸¸ #
.
¸¸# $
Null
¸¸$ (
)
¸¸( )
count
˝˝ 
++
˝˝ 
;
˝˝ 
return
˛˛ 

count
˛˛ 
;
˛˛ 
}
ˇˇ 
(
ÅÅ 
int
ÅÅ 
Row
ÅÅ 
,
ÅÅ 
int
ÅÅ 
Column
ÅÅ 
)
ÅÅ 
?
ÅÅ 
GetRandomNull
ÅÅ '
(
ÅÅ' (
int
ÅÅ( +
?
ÅÅ+ ,
	nullCount
ÅÅ- 6
=
ÅÅ7 8
null
ÅÅ9 =
)
ÅÅ= >
{
ÇÇ 
int
ÉÉ 
nullCountInt
ÉÉ 
=
ÉÉ 
	nullCount
ÉÉ  
??
ÉÉ! #

CountNulls
ÉÉ$ .
(
ÉÉ. /
)
ÉÉ/ 0
;
ÉÉ0 1
if
ÖÖ 
(
ÖÖ 
nullCountInt
ÖÖ 
<=
ÖÖ 
$num
ÖÖ 
)
ÖÖ 
return
ÖÖ !
null
ÖÖ" &
;
ÖÖ& '
int
áá 
index
áá 
=
áá 
random
áá 
.
áá 
Next
áá 
(
áá 
$num
áá 
,
áá 
nullCountInt
áá +
+
áá, -
$num
áá. /
)
áá/ 0
;
áá0 1
(
àà 
int
àà 
,
àà 	
int
àà
 
)
àà 
@null
àà 
=
àà 
default
àà 
;
àà 
for
ââ 
(
ââ 	
int
ââ	 
row
ââ 
=
ââ 
$num
ââ 
;
ââ 
row
ââ 
<
ââ 
rows
ââ  
&&
ââ! #
index
ââ$ )
>
ââ* +
$num
ââ, -
;
ââ- .
row
ââ/ 2
++
ââ2 4
)
ââ4 5
for
ää 
(
ää	 

int
ää
 
column
ää 
=
ää 
$num
ää 
;
ää 
column
ää  
<
ää! "
columns
ää# *
&&
ää+ -
index
ää. 3
>
ää4 5
$num
ää6 7
;
ää7 8
column
ää9 ?
++
ää? A
)
ääA B
if
ãã 
(
ãã	 

maze
ãã
 
[
ãã 
row
ãã 
,
ãã 
column
ãã 
]
ãã 
is
ãã 
Tile
ãã #
.
ãã# $
Null
ãã$ (
&&
ãã) +
--
ãã, .
index
ãã. 3
==
ãã4 6
$num
ãã7 8
)
ãã8 9
@null
åå 
=
åå 
(
åå 
row
åå 
,
åå 
column
åå 
)
åå 
;
åå 
return
çç 

@null
çç 
;
çç 
}
éé 
bool
êê 

MoveRandom
êê 
(
êê 
)
êê 
{
ëë 
Node
íí 
node
íí	 
=
íí 
stack
íí 
.
íí 
Peek
íí 
(
íí 
)
íí 
;
íí 
int
ìì 
i
ìì 	
=
ìì
 
$num
ìì 
;
ìì 
if
îî 
(
îî 
node
îî 
.
îî 
Row
îî 
!=
îî 
rows
îî 
-
îî 
$num
îî 
&&
îî 
!
îî  !
invalidPath
îî! ,
.
îî, -
Contains
îî- 5
(
îî5 6
(
îî6 7
node
îî7 ;
.
îî; <
Row
îî< ?
+
îî@ A
$num
îîB C
,
îîC D
node
îîE I
.
îîI J
Column
îîJ P
)
îîP Q
)
îîQ R
&&
îîS U
!
îîV W
node
îîW [
.
îî[ \
DownExplored
îî\ h
)
îîh i
directionBuffer
ïï 
[
ïï 
i
ïï 
++
ïï 
]
ïï 
=
ïï 
(
ïï 
node
ïï !
.
ïï! "
Row
ïï" %
+
ïï& '
$num
ïï( )
,
ïï) *
node
ïï+ /
.
ïï/ 0
Column
ïï0 6
)
ïï6 7
;
ïï7 8
if
ññ 
(
ññ 
node
ññ 
.
ññ 
Row
ññ 
!=
ññ 
$num
ññ 
&&
ññ 
!
ññ 
invalidPath
ññ %
.
ññ% &
Contains
ññ& .
(
ññ. /
(
ññ/ 0
node
ññ0 4
.
ññ4 5
Row
ññ5 8
-
ññ9 :
$num
ññ; <
,
ññ< =
node
ññ> B
.
ññB C
Column
ññC I
)
ññI J
)
ññJ K
&&
ññL N
!
ññO P
node
ññP T
.
ññT U

UpExplored
ññU _
)
ññ_ `
directionBuffer
óó 
[
óó 
i
óó 
++
óó 
]
óó 
=
óó 
(
óó 
node
óó !
.
óó! "
Row
óó" %
-
óó& '
$num
óó( )
,
óó) *
node
óó+ /
.
óó/ 0
Column
óó0 6
)
óó6 7
;
óó7 8
if
òò 
(
òò 
node
òò 
.
òò 
Column
òò 
!=
òò 
$num
òò 
&&
òò 
!
òò 
invalidPath
òò (
.
òò( )
Contains
òò) 1
(
òò1 2
(
òò2 3
node
òò3 7
.
òò7 8
Row
òò8 ;
,
òò; <
node
òò= A
.
òòA B
Column
òòB H
-
òòI J
$num
òòK L
)
òòL M
)
òòM N
&&
òòO Q
!
òòR S
node
òòS W
.
òòW X
LeftExplored
òòX d
)
òòd e
directionBuffer
ôô 
[
ôô 
i
ôô 
++
ôô 
]
ôô 
=
ôô 
(
ôô 
node
ôô !
.
ôô! "
Row
ôô" %
,
ôô% &
node
ôô' +
.
ôô+ ,
Column
ôô, 2
-
ôô3 4
$num
ôô5 6
)
ôô6 7
;
ôô7 8
if
öö 
(
öö 
node
öö 
.
öö 
Column
öö 
!=
öö 
columns
öö 
-
öö  
$num
öö! "
&&
öö# %
!
öö& '
invalidPath
öö' 2
.
öö2 3
Contains
öö3 ;
(
öö; <
(
öö< =
node
öö= A
.
ööA B
Row
ööB E
,
ööE F
node
ööG K
.
ööK L
Column
ööL R
+
ööS T
$num
ööU V
)
ööV W
)
ööW X
&&
ööY [
!
öö\ ]
node
öö] a
.
ööa b
RightExplored
ööb o
)
ööo p
directionBuffer
õõ 
[
õõ 
i
õõ 
++
õõ 
]
õõ 
=
õõ 
(
õõ 
node
õõ !
.
õõ! "
Row
õõ" %
,
õõ% &
node
õõ' +
.
õõ+ ,
Column
õõ, 2
+
õõ3 4
$num
õõ5 6
)
õõ6 7
;
õõ7 8
if
úú 
(
úú 
i
úú 	
is
úú
 
$num
úú 
)
úú 
return
ùù 
false
ùù 
;
ùù 
var
ûû 
move
ûû 
=
ûû 
directionBuffer
ûû 
[
ûû 
random
ûû %
.
ûû% &
Next
ûû& *
(
ûû* +
$num
ûû+ ,
,
ûû, -
i
ûû. /
)
ûû/ 0
]
ûû0 1
;
ûû1 2
if
üü 
(
üü 
move
üü 
.
üü 
Row
üü 
==
üü 
node
üü 
.
üü 
Row
üü 
+
üü 
$num
üü  
)
üü  !
{
†† 
node
°° 	
.
°°	 

DownExplored
°°
 
=
°° 
true
°° 
;
°° 
maze
¢¢ 	
[
¢¢	 

node
¢¢
 
.
¢¢ 
Row
¢¢ 
,
¢¢ 
node
¢¢ 
.
¢¢ 
Column
¢¢ 
]
¢¢  
|=
¢¢! #
Tile
¢¢$ (
.
¢¢( )
Down
¢¢) -
;
¢¢- .
maze
££ 	
[
££	 

move
££
 
.
££ 
Row
££ 
,
££ 
move
££ 
.
££ 
Column
££ 
]
££  
|=
££! #
previousMove
££$ 0
=
££1 2
Tile
££3 7
.
££7 8
Up
££8 :
;
££: ;
}
§§ 
if
•• 
(
•• 
move
•• 
.
•• 
Row
•• 
==
•• 
node
•• 
.
•• 
Row
•• 
-
•• 
$num
••  
)
••  !
{
¶¶ 
node
ßß 	
.
ßß	 


UpExplored
ßß
 
=
ßß 
true
ßß 
;
ßß 
maze
®® 	
[
®®	 

node
®®
 
.
®® 
Row
®® 
,
®® 
node
®® 
.
®® 
Column
®® 
]
®®  
|=
®®! #
Tile
®®$ (
.
®®( )
Up
®®) +
;
®®+ ,
maze
©© 	
[
©©	 

move
©©
 
.
©© 
Row
©© 
,
©© 
move
©© 
.
©© 
Column
©© 
]
©©  
|=
©©! #
previousMove
©©$ 0
=
©©1 2
Tile
©©3 7
.
©©7 8
Down
©©8 <
;
©©< =
}
™™ 
if
´´ 
(
´´ 
move
´´ 
.
´´ 
Column
´´ 
==
´´ 
node
´´ 
.
´´ 
Column
´´ "
-
´´# $
$num
´´% &
)
´´& '
{
¨¨ 
node
≠≠ 	
.
≠≠	 

LeftExplored
≠≠
 
=
≠≠ 
true
≠≠ 
;
≠≠ 
maze
ÆÆ 	
[
ÆÆ	 

node
ÆÆ
 
.
ÆÆ 
Row
ÆÆ 
,
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Column
ÆÆ 
]
ÆÆ  
|=
ÆÆ! #
Tile
ÆÆ$ (
.
ÆÆ( )
Left
ÆÆ) -
;
ÆÆ- .
maze
ØØ 	
[
ØØ	 

move
ØØ
 
.
ØØ 
Row
ØØ 
,
ØØ 
move
ØØ 
.
ØØ 
Column
ØØ 
]
ØØ  
|=
ØØ! #
previousMove
ØØ$ 0
=
ØØ1 2
Tile
ØØ3 7
.
ØØ7 8
Right
ØØ8 =
;
ØØ= >
}
∞∞ 
if
±± 
(
±± 
move
±± 
.
±± 
Column
±± 
==
±± 
node
±± 
.
±± 
Column
±± "
+
±±# $
$num
±±% &
)
±±& '
{
≤≤ 
node
≥≥ 	
.
≥≥	 

RightExplored
≥≥
 
=
≥≥ 
true
≥≥ 
;
≥≥ 
maze
¥¥ 	
[
¥¥	 

node
¥¥
 
.
¥¥ 
Row
¥¥ 
,
¥¥ 
node
¥¥ 
.
¥¥ 
Column
¥¥ 
]
¥¥  
|=
¥¥! #
Tile
¥¥$ (
.
¥¥( )
Right
¥¥) .
;
¥¥. /
maze
µµ 	
[
µµ	 

move
µµ
 
.
µµ 
Row
µµ 
,
µµ 
move
µµ 
.
µµ 
Column
µµ 
]
µµ  
|=
µµ! #
previousMove
µµ$ 0
=
µµ1 2
Tile
µµ3 7
.
µµ7 8
Left
µµ8 <
;
µµ< =
}
∂∂ 
stack
∑∑ 	
.
∑∑	 

Push
∑∑
 
(
∑∑ 
new
∑∑ 
Node
∑∑ 
(
∑∑ 
)
∑∑ 
{
∏∏ 
Row
ππ 
=
ππ	 

move
ππ 
.
ππ 
Row
ππ 
,
ππ 
Column
∫∫ 
=
∫∫ 
move
∫∫ 
.
∫∫ 
Column
∫∫ 
,
∫∫ 
}
ªª 
)
ªª 
;
ªª 
invalidPath
ºº 
.
ºº 
Add
ºº 
(
ºº 
(
ºº 
node
ºº 
.
ºº 
Row
ºº 
,
ºº 
node
ºº #
.
ºº# $
Column
ºº$ *
)
ºº* +
)
ºº+ ,
;
ºº, -
return
ΩΩ 

true
ΩΩ 
;
ΩΩ 
}
ææ 
(
¿¿ 
int
¿¿ 
Row
¿¿ 
,
¿¿ 
int
¿¿ 
Column
¿¿ 
)
¿¿ 
?
¿¿ 
	nullStart
¿¿ #
;
¿¿# $
while
¡¡ 
(
¡¡	 

(
¡¡
 
	nullStart
¡¡ 
=
¡¡ 
GetRandomNull
¡¡ $
(
¡¡$ %
)
¡¡% &
)
¡¡& '
.
¡¡' (
HasValue
¡¡( 0
)
¡¡0 1
{
¬¬ 
stack
√√ 	
.
√√	 

Clear
√√
 
(
√√ 
)
√√ 
;
√√ 
invalidPath
ƒƒ 
.
ƒƒ 
Clear
ƒƒ 
(
ƒƒ 
)
ƒƒ 
;
ƒƒ 
stack
≈≈ 	
.
≈≈	 

Push
≈≈
 
(
≈≈ 
new
≈≈ 
Node
≈≈ 
(
≈≈ 
)
≈≈ 
{
∆∆ 
Row
«« 
=
««	 

	nullStart
«« 
.
«« 
Value
«« 
.
«« 
Row
«« 
,
«« 
Column
»» 
=
»» 
	nullStart
»» 
.
»» 
Value
»» 
.
»» 
Column
»» $
,
»»$ %
}
…… 
)
…… 
;
…… 
invalidPath
   
.
   
Add
   
(
   
(
   
	nullStart
   
.
   
Value
   $
.
  $ %
Row
  % (
,
  ( )
	nullStart
  * 3
.
  3 4
Value
  4 9
.
  9 :
Column
  : @
)
  @ A
)
  A B
;
  B C
previousMove
ÀÀ 
=
ÀÀ 
Tile
ÀÀ 
.
ÀÀ 
Null
ÀÀ 
;
ÀÀ 
while
ÃÃ 	
(
ÃÃ
 
maze
ÃÃ 
[
ÃÃ 
stack
ÃÃ 
.
ÃÃ 
Peek
ÃÃ 
(
ÃÃ 
)
ÃÃ 
.
ÃÃ 
Row
ÃÃ  
,
ÃÃ  !
stack
ÃÃ" '
.
ÃÃ' (
Peek
ÃÃ( ,
(
ÃÃ, -
)
ÃÃ- .
.
ÃÃ. /
Column
ÃÃ/ 5
]
ÃÃ5 6
==
ÃÃ7 9
previousMove
ÃÃ: F
)
ÃÃF G
{
ÕÕ 
if
ŒŒ 
(
ŒŒ 	
!
ŒŒ	 


MoveRandom
ŒŒ
 
(
ŒŒ 
)
ŒŒ 
)
ŒŒ 
{
œœ 
Node
–– 

move
–– 
=
–– 
stack
–– 
.
–– 
Pop
–– 
(
–– 
)
–– 
;
–– 
Node
—— 

parent
—— 
=
—— 
stack
—— 
.
—— 
Peek
—— 
(
—— 
)
——  
;
——  !
if
““ 
(
““	 

move
““
 
.
““ 
Row
““ 
==
““ 
parent
““ 
.
““ 
Row
““  
-
““! "
$num
““# $
)
““$ %
{
”” 
maze
‘‘ 
[
‘‘ 
move
‘‘ 
.
‘‘ 
Row
‘‘ 
,
‘‘ 
move
‘‘ 
.
‘‘ 
Column
‘‘ !
]
‘‘! "
&=
‘‘# %
~
‘‘& '
Tile
‘‘' +
.
‘‘+ ,
Down
‘‘, 0
;
‘‘0 1
maze
’’ 
[
’’ 
parent
’’ 
.
’’ 
Row
’’ 
,
’’ 
parent
’’ 
.
’’ 
Column
’’ %
]
’’% &
&=
’’' )
~
’’* +
Tile
’’+ /
.
’’/ 0
Up
’’0 2
;
’’2 3
}
÷÷ 
if
◊◊ 
(
◊◊	 

move
◊◊
 
.
◊◊ 
Row
◊◊ 
==
◊◊ 
parent
◊◊ 
.
◊◊ 
Row
◊◊  
+
◊◊! "
$num
◊◊# $
)
◊◊$ %
{
ÿÿ 
maze
ŸŸ 
[
ŸŸ 
move
ŸŸ 
.
ŸŸ 
Row
ŸŸ 
,
ŸŸ 
move
ŸŸ 
.
ŸŸ 
Column
ŸŸ !
]
ŸŸ! "
&=
ŸŸ# %
~
ŸŸ& '
Tile
ŸŸ' +
.
ŸŸ+ ,
Up
ŸŸ, .
;
ŸŸ. /
maze
⁄⁄ 
[
⁄⁄ 
parent
⁄⁄ 
.
⁄⁄ 
Row
⁄⁄ 
,
⁄⁄ 
parent
⁄⁄ 
.
⁄⁄ 
Column
⁄⁄ %
]
⁄⁄% &
&=
⁄⁄' )
~
⁄⁄* +
Tile
⁄⁄+ /
.
⁄⁄/ 0
Down
⁄⁄0 4
;
⁄⁄4 5
}
€€ 
if
‹‹ 
(
‹‹	 

move
‹‹
 
.
‹‹ 
Column
‹‹ 
==
‹‹ 
parent
‹‹ 
.
‹‹  
Column
‹‹  &
+
‹‹' (
$num
‹‹) *
)
‹‹* +
{
›› 
maze
ﬁﬁ 
[
ﬁﬁ 
move
ﬁﬁ 
.
ﬁﬁ 
Row
ﬁﬁ 
,
ﬁﬁ 
move
ﬁﬁ 
.
ﬁﬁ 
Column
ﬁﬁ !
]
ﬁﬁ! "
&=
ﬁﬁ# %
~
ﬁﬁ& '
Tile
ﬁﬁ' +
.
ﬁﬁ+ ,
Left
ﬁﬁ, 0
;
ﬁﬁ0 1
maze
ﬂﬂ 
[
ﬂﬂ 
parent
ﬂﬂ 
.
ﬂﬂ 
Row
ﬂﬂ 
,
ﬂﬂ 
parent
ﬂﬂ 
.
ﬂﬂ 
Column
ﬂﬂ %
]
ﬂﬂ% &
&=
ﬂﬂ' )
~
ﬂﬂ* +
Tile
ﬂﬂ+ /
.
ﬂﬂ/ 0
Right
ﬂﬂ0 5
;
ﬂﬂ5 6
}
‡‡ 
if
·· 
(
··	 

move
··
 
.
·· 
Column
·· 
==
·· 
parent
·· 
.
··  
Column
··  &
-
··' (
$num
··) *
)
··* +
{
‚‚ 
maze
„„ 
[
„„ 
move
„„ 
.
„„ 
Row
„„ 
,
„„ 
move
„„ 
.
„„ 
Column
„„ !
]
„„! "
&=
„„# %
~
„„& '
Tile
„„' +
.
„„+ ,
Right
„„, 1
;
„„1 2
maze
‰‰ 
[
‰‰ 
parent
‰‰ 
.
‰‰ 
Row
‰‰ 
,
‰‰ 
parent
‰‰ 
.
‰‰ 
Column
‰‰ %
]
‰‰% &
&=
‰‰' )
~
‰‰* +
Tile
‰‰+ /
.
‰‰/ 0
Left
‰‰0 4
;
‰‰4 5
}
ÂÂ 
}
ÊÊ 
}
ÓÓ 
}
ÔÔ 
}
 
return
ÚÚ 
maze
ÚÚ	 
;
ÚÚ 
}
ÛÛ 
public
˘˘ 
class
˘˘ 
Graph
˘˘ 
{
˙˙ 
public
˚˚ 
class
˚˚	 
Node
˚˚ 
{
¸¸ 
public
˝˝ 	
int
˝˝
 
OwnIndex
˝˝ 
{
˝˝ 
get
˝˝ 
;
˝˝ 
}
˝˝ 
public
˛˛ 	
List
˛˛
 
<
˛˛ 
int
˛˛ 
>
˛˛ 
Connections
˛˛ 
{
˛˛  !
get
˛˛" %
;
˛˛% &
}
˛˛' (
public
ˇˇ 	
List
ˇˇ
 
<
ˇˇ 
double
ˇˇ 
>
ˇˇ 
Costs
ˇˇ 
{
ˇˇ 
get
ˇˇ "
;
ˇˇ" #
}
ˇˇ$ %
public
ÅÅ 	
void
ÅÅ
 
Add
ÅÅ 
(
ÅÅ 
int
ÅÅ 
other
ÅÅ 
,
ÅÅ 
double
ÅÅ $
cost
ÅÅ% )
)
ÅÅ) *
{
ÇÇ 
Connections
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ 
other
ÉÉ 
)
ÉÉ 
;
ÉÉ 
Costs
ÑÑ 	
.
ÑÑ	 

Add
ÑÑ
 
(
ÑÑ 
cost
ÑÑ 
)
ÑÑ 
;
ÑÑ 
}
ÖÖ 
public
áá 	
Node
áá
 
(
áá 
int
áá 
ownIndex
áá 
)
áá 
{
àà 
OwnIndex
ââ 
=
ââ 
ownIndex
ââ 
;
ââ 
Connections
ää 
=
ää 
new
ää 
List
ää 
<
ää 
int
ää 
>
ää 
(
ää  
)
ää  !
;
ää! "
Costs
ãã 	
=
ãã
 
new
ãã 
List
ãã 
<
ãã 
double
ãã 
>
ãã 
(
ãã 
)
ãã 
;
ãã 
}
åå 
}
çç 
public
èè 
Node
èè	 
[
èè 
]
èè 
Nodes
èè 
{
èè 
get
èè 
;
èè 
}
èè 
public
ëë 
Graph
ëë	 
(
ëë 
Node
ëë 
[
ëë 
]
ëë 
nodes
ëë 
)
ëë 
{
íí 
Nodes
ìì 
=
ìì	 

nodes
ìì 
??
ìì 
throw
ìì 
new
ìì #
ArgumentNullException
ìì 3
(
ìì3 4
nameof
ìì4 :
(
ìì: ;
nodes
ìì; @
)
ìì@ A
)
ììA B
;
ììB C
}
îî 
public
ññ 
static
ññ	 
Maze
ññ 
.
ññ 
Tile
ññ 
[
ññ 
,
ññ 
]
ññ 
ConvertToGrid
ññ *
(
ññ* +
Graph
ññ+ 0
graph
ññ1 6
,
ññ6 7
int
ññ8 ;
rows
ññ< @
,
ññ@ A
int
ññB E
columns
ññF M
,
ññM N
Func
ññO S
<
ññS T
int
ññT W
,
ññW X
int
ññY \
,
ññ\ ]
int
ññ^ a
>
ñña b
index
ññc h
,
ññh i
int
ññj m
	start_row
ññn w
,
ññw x
int
ññy |
start_columnññ} â
,ññâ ä
intññã é
end_rowññè ñ
,ñññ ó
intññò õ

end_columnññú ¶
)ññ¶ ß
{
óó 
var
òò 
tiles
òò 
=
òò 
new
òò 
Maze
òò 
.
òò 
Tile
òò 
[
òò 
rows
òò !
,
òò! "
columns
òò# *
]
òò* +
;
òò+ ,
foreach
öö 

(
öö 
var
öö 
node
öö 
in
öö 
graph
öö 
.
öö 
Nodes
öö #
)
öö# $
{
õõ 
if
úú 
(
úú 
node
úú 
==
úú 
null
úú 
)
úú 
continue
ùù 
;
ùù 
(
üü 
int
üü 
,
üü 	
int
üü
 
)
üü 
Unpack
üü 
(
üü 
int
üü 
i
üü 
)
üü 
=>
üü 
(
üü  !
i
üü! "
%
üü# $
rows
üü% )
,
üü) *
i
üü+ ,
/
üü- .
rows
üü/ 3
)
üü3 4
;
üü4 5
var
°° 
(
°° 	
row
°°	 
,
°° 
col
°° 
)
°° 
=
°° 
Unpack
°° 
(
°° 
node
°°  
.
°°  !
OwnIndex
°°! )
)
°°) *
;
°°* +
if
§§ 
(
§§ 
node
§§ 
.
§§ 
Connections
§§ 
.
§§ 
Contains
§§ !
(
§§! "
index
§§" '
(
§§' (
row
§§( +
-
§§, -
$num
§§. /
,
§§/ 0
col
§§1 4
)
§§4 5
)
§§5 6
)
§§6 7
{
•• 
tiles
¶¶ 

[
¶¶
 
row
¶¶ 
,
¶¶ 
col
¶¶ 
]
¶¶ 
|=
¶¶ 
Maze
¶¶ 
.
¶¶ 
Tile
¶¶ !
.
¶¶! "
Up
¶¶" $
;
¶¶$ %
tiles
ßß 

[
ßß
 
row
ßß 
-
ßß 
$num
ßß 
,
ßß 
col
ßß 
]
ßß 
|=
ßß 
Maze
ßß  
.
ßß  !
Tile
ßß! %
.
ßß% &
Down
ßß& *
;
ßß* +
}
®® 
if
©© 
(
©© 
node
©© 
.
©© 
Connections
©© 
.
©© 
Contains
©© !
(
©©! "
index
©©" '
(
©©' (
row
©©( +
+
©©, -
$num
©©. /
,
©©/ 0
col
©©1 4
)
©©4 5
)
©©5 6
)
©©6 7
{
™™ 
tiles
´´ 

[
´´
 
row
´´ 
,
´´ 
col
´´ 
]
´´ 
|=
´´ 
Maze
´´ 
.
´´ 
Tile
´´ !
.
´´! "
Down
´´" &
;
´´& '
tiles
¨¨ 

[
¨¨
 
row
¨¨ 
+
¨¨ 
$num
¨¨ 
,
¨¨ 
col
¨¨ 
]
¨¨ 
|=
¨¨ 
Maze
¨¨  
.
¨¨  !
Tile
¨¨! %
.
¨¨% &
Up
¨¨& (
;
¨¨( )
}
≠≠ 
if
ÆÆ 
(
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Connections
ÆÆ 
.
ÆÆ 
Contains
ÆÆ !
(
ÆÆ! "
index
ÆÆ" '
(
ÆÆ' (
row
ÆÆ( +
,
ÆÆ+ ,
col
ÆÆ- 0
-
ÆÆ1 2
$num
ÆÆ3 4
)
ÆÆ4 5
)
ÆÆ5 6
)
ÆÆ6 7
{
ØØ 
tiles
∞∞ 

[
∞∞
 
row
∞∞ 
,
∞∞ 
col
∞∞ 
]
∞∞ 
|=
∞∞ 
Maze
∞∞ 
.
∞∞ 
Tile
∞∞ !
.
∞∞! "
Left
∞∞" &
;
∞∞& '
tiles
±± 

[
±±
 
row
±± 
,
±± 
col
±± 
-
±± 
$num
±± 
]
±± 
|=
±± 
Maze
±±  
.
±±  !
Tile
±±! %
.
±±% &
Right
±±& +
;
±±+ ,
}
≤≤ 
if
≥≥ 
(
≥≥ 
node
≥≥ 
.
≥≥ 
Connections
≥≥ 
.
≥≥ 
Contains
≥≥ !
(
≥≥! "
index
≥≥" '
(
≥≥' (
row
≥≥( +
,
≥≥+ ,
col
≥≥- 0
+
≥≥1 2
$num
≥≥3 4
)
≥≥4 5
)
≥≥5 6
)
≥≥6 7
{
¥¥ 
tiles
µµ 

[
µµ
 
row
µµ 
,
µµ 
col
µµ 
]
µµ 
|=
µµ 
Maze
µµ 
.
µµ 
Tile
µµ !
.
µµ! "
Right
µµ" '
;
µµ' (
tiles
∂∂ 

[
∂∂
 
row
∂∂ 
,
∂∂ 
col
∂∂ 
+
∂∂ 
$num
∂∂ 
]
∂∂ 
|=
∂∂ 
Maze
∂∂  
.
∂∂  !
Tile
∂∂! %
.
∂∂% &
Left
∂∂& *
;
∂∂* +
}
∑∑ 
if
∫∫ 
(
∫∫ 
row
∫∫ 
==
∫∫ 
	start_row
∫∫ 
&&
∫∫ 
col
∫∫ 
==
∫∫  "
start_column
∫∫# /
)
∫∫/ 0
{
ªª 
tiles
ºº 

[
ºº
 
row
ºº 
,
ºº 
col
ºº 
]
ºº 
|=
ºº 
Maze
ºº 
.
ºº 
Tile
ºº !
.
ºº! "
Start
ºº" '
;
ºº' (
}
ΩΩ 
if
ææ 
(
ææ 
row
ææ 
==
ææ 
end_row
ææ 
&&
ææ 
col
ææ 
==
ææ  

end_column
ææ! +
)
ææ+ ,
{
øø 
tiles
¿¿ 

[
¿¿
 
row
¿¿ 
,
¿¿ 
col
¿¿ 
]
¿¿ 
|=
¿¿ 
Maze
¿¿ 
.
¿¿ 
Tile
¿¿ !
.
¿¿! "
End
¿¿" %
;
¿¿% &
}
¡¡ 
}
¬¬ 
return
√√ 	
tiles
√√
 
;
√√ 
}
ƒƒ 
}
≈≈ 
public
«« 
static
«« 
Tile
«« 
[
«« 
,
«« 
]
«« 
GeneratePrims
«« $
(
««$ %
int
»» 
rows
»» 

,
»»
 
int
»» 
columns
»» 
,
»» 
int
…… 
?
…… 
	start_row
…… 
=
…… 
null
…… 
,
…… 
int
…… 
?
…… 
start_column
…… *
=
……+ ,
null
……- 1
,
……1 2
int
   
?
   
end_row
   
=
   
null
   
,
   
int
   
?
   

end_column
   &
=
  ' (
null
  ) -
)
  - .
{
ÀÀ 
	start_row
ÃÃ 
??=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
start_column
ÕÕ 
??=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
end_row
ŒŒ 	
??=
ŒŒ
 
rows
ŒŒ 
-
ŒŒ 
$num
ŒŒ 
;
ŒŒ 

end_column
œœ 
??=
œœ 
columns
œœ 
-
œœ 
$num
œœ 
;
œœ 
var
—— 
grid
—— 

=
—— 
new
—— 
Graph
—— 
.
—— 
Node
—— 
[
—— 
rows
——  
*
——! "
columns
——# *
]
——* +
;
——+ ,
int
”” 
Index
”” 
(
”” 
int
”” 
row
”” 
,
”” 
int
”” 
col
”” 
)
”” 
=>
””  
row
””! $
+
””% &
rows
””' +
*
””, -
col
””. 1
;
””1 2
var
’’ 
random
’’ 
=
’’ 
new
’’ 
Random
’’ 
(
’’ 
)
’’ 
;
’’ 
for
◊◊ 
(
◊◊ 
int
◊◊ 

row
◊◊ 
=
◊◊ 
$num
◊◊ 
;
◊◊ 
row
◊◊ 
<
◊◊ 
rows
◊◊ 
;
◊◊ 
row
◊◊  #
++
◊◊# %
)
◊◊% &
{
ÿÿ 
for
ŸŸ 
(
ŸŸ 
int
ŸŸ 
col
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
col
ŸŸ 
<
ŸŸ 
columns
ŸŸ "
;
ŸŸ" #
col
ŸŸ$ '
++
ŸŸ' )
)
ŸŸ) *
{
⁄⁄ 
var
€€ 
n
€€ 	
=
€€
 
new
€€ 
Graph
€€ 
.
€€ 
Node
€€ 
(
€€ 
Index
€€  
(
€€  !
row
€€! $
,
€€$ %
col
€€& )
)
€€) *
)
€€* +
;
€€+ ,
if
‹‹ 
(
‹‹ 
row
‹‹ 
+
‹‹ 
$num
‹‹ 
<
‹‹ 
rows
‹‹ 
)
‹‹ 
{
›› 
n
ﬁﬁ 
.
ﬁﬁ 
Add
ﬁﬁ 

(
ﬁﬁ
 
Index
ﬁﬁ 
(
ﬁﬁ 
row
ﬁﬁ 
+
ﬁﬁ 
$num
ﬁﬁ 
,
ﬁﬁ 
col
ﬁﬁ 
)
ﬁﬁ 
,
ﬁﬁ 
random
ﬁﬁ  &
.
ﬁﬁ& '

NextDouble
ﬁﬁ' 1
(
ﬁﬁ1 2
)
ﬁﬁ2 3
)
ﬁﬁ3 4
;
ﬁﬁ4 5
}
ﬂﬂ 
if
‡‡ 
(
‡‡ 
row
‡‡ 
-
‡‡ 
$num
‡‡ 
>=
‡‡ 
$num
‡‡ 
)
‡‡ 
{
·· 
n
‚‚ 
.
‚‚ 
Add
‚‚ 

(
‚‚
 
Index
‚‚ 
(
‚‚ 
row
‚‚ 
-
‚‚ 
$num
‚‚ 
,
‚‚ 
col
‚‚ 
)
‚‚ 
,
‚‚ 
random
‚‚  &
.
‚‚& '

NextDouble
‚‚' 1
(
‚‚1 2
)
‚‚2 3
)
‚‚3 4
;
‚‚4 5
}
„„ 
if
‰‰ 
(
‰‰ 
col
‰‰ 
+
‰‰ 
$num
‰‰ 
<
‰‰ 
columns
‰‰ 
)
‰‰ 
{
ÂÂ 
n
ÊÊ 
.
ÊÊ 
Add
ÊÊ 

(
ÊÊ
 
Index
ÊÊ 
(
ÊÊ 
row
ÊÊ 
,
ÊÊ 
col
ÊÊ 
+
ÊÊ 
$num
ÊÊ 
)
ÊÊ 
,
ÊÊ 
random
ÊÊ  &
.
ÊÊ& '

NextDouble
ÊÊ' 1
(
ÊÊ1 2
)
ÊÊ2 3
)
ÊÊ3 4
;
ÊÊ4 5
}
ÁÁ 
if
ËË 
(
ËË 
col
ËË 
-
ËË 
$num
ËË 
>=
ËË 
$num
ËË 
)
ËË 
{
ÈÈ 
n
ÍÍ 
.
ÍÍ 
Add
ÍÍ 

(
ÍÍ
 
Index
ÍÍ 
(
ÍÍ 
row
ÍÍ 
,
ÍÍ 
col
ÍÍ 
-
ÍÍ 
$num
ÍÍ 
)
ÍÍ 
,
ÍÍ 
random
ÍÍ  &
.
ÍÍ& '

NextDouble
ÍÍ' 1
(
ÍÍ1 2
)
ÍÍ2 3
)
ÍÍ3 4
;
ÍÍ4 5
}
ÎÎ 
grid
ÏÏ 
[
ÏÏ 	
Index
ÏÏ	 
(
ÏÏ 
row
ÏÏ 
,
ÏÏ 
col
ÏÏ 
)
ÏÏ 
]
ÏÏ 
=
ÏÏ 
n
ÏÏ 
;
ÏÏ 
}
ÌÌ 
}
ÓÓ 
var
 
graph
 
=
 
new
 
Graph
 
(
 
grid
 
)
 
;
 
var
˘˘ 
res
˘˘ 	
=
˘˘
 
SimplePrims
˘˘ 
(
˘˘ 
graph
˘˘ 
)
˘˘ 
;
˘˘ 
return
¸¸ 
Graph
¸¸	 
.
¸¸ 
ConvertToGrid
¸¸ 
(
¸¸ 
res
¸¸  
,
¸¸  !
rows
¸¸" &
,
¸¸& '
columns
¸¸( /
,
¸¸/ 0
Index
¸¸1 6
,
¸¸6 7
	start_row
¸¸8 A
.
¸¸A B
Value
¸¸B G
,
¸¸G H
start_column
¸¸I U
.
¸¸U V
Value
¸¸V [
,
¸¸[ \
end_row
¸¸] d
.
¸¸d e
Value
¸¸e j
,
¸¸j k

end_column
¸¸l v
.
¸¸v w
Value
¸¸w |
)
¸¸| }
;
¸¸} ~
}
˝˝ 
private
ˇˇ 
readonly
ˇˇ	 
struct
ˇˇ 
TwoWayConnection
ˇˇ )
:
ˇˇ* +
IComparable
ˇˇ, 7
<
ˇˇ7 8
TwoWayConnection
ˇˇ8 H
>
ˇˇH I
{
ÄÄ 
public
ÅÅ 
readonly
ÅÅ	 
int
ÅÅ 
IndexA
ÅÅ 
;
ÅÅ 
public
ÇÇ 
readonly
ÇÇ	 
int
ÇÇ 
IndexB
ÇÇ 
;
ÇÇ 
public
ÉÉ 
readonly
ÉÉ	 
double
ÉÉ 
Cost
ÉÉ 
;
ÉÉ 
public
ÖÖ 
TwoWayConnection
ÖÖ	 
(
ÖÖ 
int
ÖÖ 
indexA
ÖÖ $
,
ÖÖ$ %
int
ÖÖ& )
indexB
ÖÖ* 0
,
ÖÖ0 1
double
ÖÖ2 8
cost
ÖÖ9 =
)
ÖÖ= >
{
ÜÜ 
IndexA
áá 	
=
áá
 
indexA
áá 
;
áá 
IndexB
àà 	
=
àà
 
indexB
àà 
;
àà 
Cost
ââ 
=
ââ 	
cost
ââ
 
;
ââ 
}
ää 
public
åå 
int
åå	 
	CompareTo
åå 
(
åå 
TwoWayConnection
åå '
other
åå( -
)
åå- .
=>
åå/ 1
other
åå2 7
.
åå7 8
Cost
åå8 <
.
åå< =
	CompareTo
åå= F
(
ååF G
Cost
ååG K
)
ååK L
;
ååL M
}
çç 
public
èè 
static
èè 
Graph
èè 
SimplePrims
èè  
(
èè  !
Graph
èè! &
graph
èè' ,
)
ìì 
{
îî 
var
ïï 
newGraph
ïï 
=
ïï 
new
ïï 
Graph
ïï 
(
ïï 
new
ïï 
Graph
ïï $
.
ïï$ %
Node
ïï% )
[
ïï) *
graph
ïï* /
.
ïï/ 0
Nodes
ïï0 5
.
ïï5 6
Length
ïï6 <
]
ïï< =
)
ïï= >
;
ïï> ?
var
ññ 
nodes
ññ 
=
ññ 
graph
ññ 
.
ññ 
Nodes
ññ 
;
ññ 
var
óó 
current
óó 
=
óó 
nodes
óó 
[
óó 
$num
óó 
]
óó 
;
óó 
newGraph
òò 

.
òò
 
Nodes
òò 
[
òò 
$num
òò 
]
òò 
=
òò 
new
òò 
Graph
òò 
.
òò  
Node
òò  $
(
òò$ %
$num
òò% &
)
òò& '
;
òò' (
var
öö 
heap
öö 

=
öö 
	HeapArray
öö 
.
öö 
New
öö 
<
öö 
TwoWayConnection
öö +
>
öö+ ,
(
öö, -
)
öö- .
;
öö. /
while
úú 
(
úú 	
true
úú	 
)
úú 
{
ùù 
for
ûû 
(
ûû 
int
ûû 
i
ûû 
=
ûû 
$num
ûû 
;
ûû 
i
ûû 
<
ûû 
current
ûû 
.
ûû 
Connections
ûû *
.
ûû* +
Count
ûû+ 0
;
ûû0 1
i
ûû2 3
++
ûû3 5
)
ûû5 6
{
üü 
heap
†† 
.
†† 	
Enqueue
††	 
(
†† 
new
†† 
TwoWayConnection
†† %
(
††% &
current
††& -
.
††- .
OwnIndex
††. 6
,
††6 7
current
††8 ?
.
††? @
Connections
††@ K
[
††K L
i
††L M
]
††M N
,
††N O
current
††P W
.
††W X
Costs
††X ]
[
††] ^
i
††^ _
]
††_ `
)
††` a
)
††a b
;
††b c
}
°° 
TwoWayConnection
££ 
c
££ 
;
££ 
do
§§ 
{
•• 
if
¶¶ 
(
¶¶ 
heap
¶¶ 
.
¶¶ 
Count
¶¶ 
==
¶¶ 
$num
¶¶ 
)
¶¶ 
{
ßß 
return
®® 
newGraph
®® 
;
®® 
}
©© 
c
™™ 
=
™™ 
heap
™™ 
.
™™ 
Dequeue
™™ 
(
™™ 
)
™™ 
;
™™ 
}
´´ 
while
¨¨ 
(
¨¨	 

newGraph
¨¨
 
.
¨¨ 
Nodes
¨¨ 
[
¨¨ 
c
¨¨ 
.
¨¨ 
IndexB
¨¨ !
]
¨¨! "
!=
¨¨# %
null
¨¨& *
)
¨¨* +
;
¨¨+ ,
newGraph
ÆÆ 
.
ÆÆ 
Nodes
ÆÆ 
[
ÆÆ 
c
ÆÆ 
.
ÆÆ 
IndexA
ÆÆ 
]
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ  
c
ÆÆ  !
.
ÆÆ! "
IndexB
ÆÆ" (
,
ÆÆ( )
c
ÆÆ* +
.
ÆÆ+ ,
Cost
ÆÆ, 0
)
ÆÆ0 1
;
ÆÆ1 2
newGraph
∞∞ 
.
∞∞ 
Nodes
∞∞ 
[
∞∞ 
c
∞∞ 
.
∞∞ 
IndexB
∞∞ 
]
∞∞ 
=
∞∞ 
new
∞∞ !
Graph
∞∞" '
.
∞∞' (
Node
∞∞( ,
(
∞∞, -
c
∞∞- .
.
∞∞. /
IndexB
∞∞/ 5
)
∞∞5 6
;
∞∞6 7
current
±± 

=
±± 
graph
±± 
.
±± 
Nodes
±± 
[
±± 
c
±± 
.
±± 
IndexB
±± !
]
±±! "
;
±±" #
newGraph
≤≤ 
.
≤≤ 
Nodes
≤≤ 
[
≤≤ 
c
≤≤ 
.
≤≤ 
IndexB
≤≤ 
]
≤≤ 
.
≤≤ 
Add
≤≤ 
(
≤≤  
c
≤≤  !
.
≤≤! "
IndexA
≤≤" (
,
≤≤( )
c
≤≤* +
.
≤≤+ ,
Cost
≤≤, 0
)
≤≤0 1
;
≤≤1 2
}
∫∫ 
}
ªª 
public
øø 
static
øø 
string
øø 
Render
øø 
(
øø 
Tile
øø !
[
øø! "
,
øø" #
]
øø# $
maze
øø% )
)
øø) *
{
¿¿ 
static
¡¡ 
char
¡¡	 
Center
¡¡ 
(
¡¡ 
Tile
¡¡ 
tile
¡¡ 
)
¡¡ 
=>
¡¡  "
tile
¬¬ 
.
¬¬ 
HasFlag
¬¬ 
(
¬¬ 
Tile
¬¬ 
.
¬¬ 
Start
¬¬ 
)
¬¬ 
?
¬¬ 
$char
¬¬ !
:
¬¬" #
tile
√√ 
.
√√ 
HasFlag
√√ 
(
√√ 
Tile
√√ 
.
√√ 
End
√√ 
)
√√ 
?
√√ 
$char
√√ 
:
√√  !
$char
ƒƒ 
;
ƒƒ 
static
∆∆ 
char
∆∆	 
Side
∆∆ 
(
∆∆ 
Tile
∆∆ 
tile
∆∆ 
,
∆∆ 
Tile
∆∆ "
flag
∆∆# '
)
∆∆' (
=>
∆∆) +
tile
«« 
.
«« 
HasFlag
«« 
(
«« 
flag
«« 
)
«« 
?
«« 
$char
«« 
:
«« 
$char
«« !
;
««! "
static
…… 
char
……	 
[
…… 
,
…… 
]
…… 

RenderTile
…… 
(
…… 
Tile
……  
tile
……! %
)
……% &
=>
……' )
new
……* -
char
……. 2
[
……2 3
,
……3 4
]
……4 5
{
   
{
ÀÀ 
$char
ÀÀ 
,
ÀÀ 	
Side
ÀÀ
 
(
ÀÀ 
tile
ÀÀ 
,
ÀÀ 
Tile
ÀÀ 
.
ÀÀ 
Up
ÀÀ 
)
ÀÀ 
,
ÀÀ 
$char
ÀÀ "
}
ÀÀ# $
,
ÀÀ$ %
{
ÃÃ 
Side
ÃÃ 	
(
ÃÃ	 

tile
ÃÃ
 
,
ÃÃ 
Tile
ÃÃ 
.
ÃÃ 
Left
ÃÃ 
)
ÃÃ 
,
ÃÃ 
Center
ÃÃ "
(
ÃÃ" #
tile
ÃÃ# '
)
ÃÃ' (
,
ÃÃ( )
Side
ÃÃ* .
(
ÃÃ. /
tile
ÃÃ/ 3
,
ÃÃ3 4
Tile
ÃÃ5 9
.
ÃÃ9 :
Right
ÃÃ: ?
)
ÃÃ? @
}
ÃÃA B
,
ÃÃB C
{
ÕÕ 
$char
ÕÕ 
,
ÕÕ 	
Side
ÕÕ
 
(
ÕÕ 
tile
ÕÕ 
,
ÕÕ 
Tile
ÕÕ 
.
ÕÕ 
Down
ÕÕ 
)
ÕÕ 
,
ÕÕ  
$char
ÕÕ! $
}
ÕÕ% &
,
ÕÕ& '
}
ŒŒ 
;
ŒŒ 
int
œœ 
rows
œœ 

=
œœ 
maze
œœ 
.
œœ 
	GetLength
œœ 
(
œœ 
$num
œœ 
)
œœ 
;
œœ 
int
–– 
columns
–– 
=
–– 
maze
–– 
.
–– 
	GetLength
–– 
(
–– 
$num
––  
)
––  !
;
––! "
char
—— 
[
—— 
,
—— 
]
—— 	
[
——	 

,
——
 
]
—— 
rendered
—— 
=
—— 
new
—— 
char
——  
[
——  !
rows
——! %
,
——% &
columns
——' .
]
——. /
[
——/ 0
,
——0 1
]
——1 2
;
——2 3
for
““ 
(
““ 
int
““ 

row
““ 
=
““ 
$num
““ 
;
““ 
row
““ 
<
““ 
rows
““ 
;
““ 
row
““  #
++
““# %
)
““% &
{
”” 
for
‘‘ 
(
‘‘ 
int
‘‘ 
column
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
column
‘‘ 
<
‘‘  
columns
‘‘! (
;
‘‘( )
column
‘‘* 0
++
‘‘0 2
)
‘‘2 3
{
’’ 
rendered
÷÷ 
[
÷÷ 
row
÷÷ 
,
÷÷ 
column
÷÷ 
]
÷÷ 
=
÷÷ 

RenderTile
÷÷ &
(
÷÷& '
maze
÷÷' +
[
÷÷+ ,
row
÷÷, /
,
÷÷/ 0
column
÷÷1 7
]
÷÷7 8
)
÷÷8 9
;
÷÷9 :
}
◊◊ 
}
ÿÿ 
int
ŸŸ 
rowsX3
ŸŸ 
=
ŸŸ 
rows
ŸŸ 
*
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
int
⁄⁄ 
	columnsX3
⁄⁄ 
=
⁄⁄ 
columns
⁄⁄ 
*
⁄⁄ 
$num
⁄⁄ 
;
⁄⁄ 
StringBuilder
€€ 
stringBuilder
€€ 
=
€€ 
new
€€  #
(
€€# $
)
€€$ %
;
€€% &
for
‹‹ 
(
‹‹ 
int
‹‹ 

row
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
row
‹‹ 
<
‹‹ 
rowsX3
‹‹  
;
‹‹  !
row
‹‹" %
++
‹‹% '
)
‹‹' (
{
›› 
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
column
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
column
ﬁﬁ 
<
ﬁﬁ  
	columnsX3
ﬁﬁ! *
;
ﬁﬁ* +
column
ﬁﬁ, 2
++
ﬁﬁ2 4
)
ﬁﬁ4 5
{
ﬂﬂ 
int
‡‡ 
tileRow
‡‡ 
=
‡‡ 
row
‡‡ 
/
‡‡ 
$num
‡‡ 
;
‡‡ 
int
·· 

tileColumn
·· 
=
·· 
column
·· 
/
·· 
$num
·· 
;
··  
int
‚‚ 
	renderRow
‚‚ 
=
‚‚ 
row
‚‚ 
%
‚‚ 
$num
‚‚ 
;
‚‚ 
int
„„ 
renderColumn
„„ 
=
„„ 
column
„„ 
%
„„ 
$num
„„  !
;
„„! "
stringBuilder
‰‰ 
.
‰‰ 
Append
‰‰ 
(
‰‰ 
rendered
‰‰ !
[
‰‰! "
tileRow
‰‰" )
,
‰‰) *

tileColumn
‰‰+ 5
]
‰‰5 6
[
‰‰6 7
	renderRow
‰‰7 @
,
‰‰@ A
renderColumn
‰‰B N
]
‰‰N O
)
‰‰O P
;
‰‰P Q
}
ÂÂ 
stringBuilder
ÊÊ 
.
ÊÊ 

AppendLine
ÊÊ 
(
ÊÊ 
)
ÊÊ 
;
ÊÊ 
}
ÁÁ 
string
ËË 
render
ËË	 
=
ËË 
stringBuilder
ËË 
.
ËË  
ToString
ËË  (
(
ËË( )
)
ËË) *
;
ËË* +
return
ÈÈ 
render
ÈÈ	 
;
ÈÈ 
}
ÍÍ 
}ÎÎ 